# Архитектура проекта PasswordHack

Проект организован по принципам **Clean Architecture** с разделением на слои.

## Структура проекта

```
src/main/kotlin/
├── domain/                    # Доменный слой (бизнес-логика)
│   ├── model/                 # Модели данных
│   │   ├── HashAlgorithm.kt  # Перечисление алгоритмов хэширования
│   │   └── BruteForceConfig.kt # Конфигурация для брутфорса
│   ├── repository/            # Интерфейсы репозиториев
│   │   └── HashChecker.kt     # Интерфейс для проверки хэшей
│   └── service/               # Бизнес-сервисы
│       ├── HashDetectionService.kt  # Определение типа хэша
│       ├── AlphabetService.kt      # Управление алфавитами
│       └── BruteForceService.kt    # Основная логика брутфорса
│
├── data/                      # Слой данных (реализации)
│   ├── checker/               # Реализации проверки хэшей
│   │   ├── MD5HashChecker.kt
│   │   ├── SHA1HashChecker.kt
│   │   ├── BcryptHashChecker.kt
│   │   ├── Argon2HashChecker.kt
│   │   └── HashCheckerFactory.kt   # Фабрика для создания checkers
│   ├── generator/             # Генерация паролей
│   │   └── PasswordGenerator.kt
│   └── accelerator/           # GPU ускорение
│       └── GPUAccelerator.kt
│
├── util/                      # Утилиты
│   └── HashUtils.kt           # Утилиты для работы с хэшами
│
└── presentation/             # Слой представления
    └── cli/                   # Командная строка
        ├── ArgumentParser.kt  # Парсинг аргументов
        ├── HelpPrinter.kt     # Вывод справки
        └── Main.kt            # Точка входа приложения
```

## Описание слоев

### Domain Layer (Доменный слой)

**Назначение**: Содержит бизнес-логику и не зависит от внешних библиотек.

- **model/**: Модели данных (enum, data class)
- **repository/**: Интерфейсы для работы с данными
- **service/**: Бизнес-логика приложения

**Зависимости**: Только стандартная библиотека Kotlin и kotlinx.coroutines

### Data Layer (Слой данных)

**Назначение**: Реализации интерфейсов из domain слоя, работа с внешними библиотеками.

- **checker/**: Реализации HashChecker для различных алгоритмов
- **generator/**: Генератор паролей для брутфорса
- **accelerator/**: GPU ускорение через OpenCL

**Зависимости**: 
- Domain layer (интерфейсы)
- Внешние библиотеки (jbcrypt, argon2-jvm, jocl)

### Util Layer (Утилиты)

**Назначение**: Вспомогательные функции, не зависящие от бизнес-логики.

- **HashUtils**: Нормализация хэшей, конвертация hex в byte array

### Presentation Layer (Слой представления)

**Назначение**: Взаимодействие с пользователем (CLI, UI и т.д.)

- **cli/**: Командная строка
  - **ArgumentParser**: Парсинг аргументов командной строки
  - **HelpPrinter**: Вывод справки
  - **Main**: Точка входа, оркестрация работы всех компонентов

## Принципы Clean Architecture

1. **Разделение ответственности**: Каждый класс имеет одну ответственность
2. **Зависимости направлены внутрь**: Domain не зависит от Data и Presentation
3. **Инверсия зависимостей**: Domain определяет интерфейсы, Data их реализует
4. **Независимость от фреймворков**: Domain слой не зависит от внешних библиотек
5. **Тестируемость**: Каждый слой можно тестировать независимо

## Поток выполнения

1. **Main.kt** получает аргументы командной строки
2. **ArgumentParser** парсит аргументы
3. **HashDetectionService** определяет тип хэша
4. **HashCheckerFactory** создает соответствующий checker
5. **AlphabetService** определяет алфавиты для поиска
6. **BruteForceService** выполняет брутфорс с использованием PasswordGenerator
7. Результат выводится пользователю

## Преимущества новой архитектуры

- ✅ **Модульность**: Легко добавлять новые алгоритмы хэширования
- ✅ **Тестируемость**: Каждый компонент можно тестировать отдельно
- ✅ **Читаемость**: Понятная структура и разделение ответственности
- ✅ **Расширяемость**: Легко добавлять новые интерфейсы (например, GUI)
- ✅ **Поддерживаемость**: Изменения в одном слое не влияют на другие

